Стратегия, Strategy — поведенческий шаблон проектирования, 
предназначенный для определения семейства алгоритмов, 
инкапсуляции  каждого из них и обеспечения их взаимозаменяемости. 

Это позволяет выбирать алгоритм путем определения соответствующего класса. 
Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

Задача
Выбор алгоритма, который следует применить, в зависимости от типа выдавшего запрос клиента или обрабатываемых данных. 
Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».

Мотивы
    * Программа должна обеспечивать различные варианты алгоритма или поведения
    * Нужно изменять поведение каждого экземпляра класса
    * Необходимо изменять поведение объектов на стадии выполнения
    * Введение интерфейса позволяет классам-клиентам ничего не знать о классах, 
      реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы

Способ решения
Отделение процедуры выбора алгоритма от его реализации. Это позволяет сделать выбор на основании контекста.

Участники
    * Класс Strategy определяет как будут использоваться различные алгоритмы.
    * Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.
    * Класс Context использует конкретные классы ConcreteStrategy посредством ссылки на конкретный тип абстрактного класса Strategy. Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма (в некоторых случаях классу Strategy требуется посылать запросы классу Context). Класс Context пересылает классу Strategy запрос, поступивший от его класса-клиента.

Следствия
    * Шаблон Strategy определяет семейство алгоритмов.
    * Это позволяет отказаться от использования переключателей и/или условных операторов.
    * Вызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь одинаковый интерфейс).

Реализация
Класс, который использует алгоритм (Context), включает абстрактный класс (Strategy), 
обладающий абстрактным методом, определяющим способ вызова алгоритма. 
Каждый производный класс реализует один требуемый вариант алгоритма.

Замечание: 
метод вызова алгоритма не должен быть абстрактным, 
если требуется реализовать некоторое поведение, принимаемое по умолчанию.